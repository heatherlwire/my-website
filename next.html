<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        /* ---------- Canonical Redirect ---------- */
        if (window.top === window.self) {
            if (location.hostname === "wirelearningsolutions.com") {
                location.replace(
                    "https://www.wirelearningsolutions.com" +
                    location.pathname +
                    location.search
                );
            }
        }
    </script>

    <meta charset="UTF-8" />
    <title>Analyzing your progress…</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
        :root {
            --bg-0: #0a0f1a;
            --bg-1: #0e1526;
            --bg-2: #0f1b33;
            --ink-0: #e8f1ff;
            --ink-1: #b9c8e8;
            --sky-1: #0ea5e9;
            --sky-2: #22d3ee;
            --err: #ef4444;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
            color: var(--ink-0);
            background: linear-gradient(180deg, #07101e 0%, #0b1628 100%);
            min-height: 100vh;
            padding: 40px 18px;
            text-align: center;
        }

        h1 {
            font-size: 26px;
            margin-bottom: 14px;
            color: var(--ink-0);
        }

        .muted {
            color: var(--ink-1);
            font-size: 16px;
        }

        #statusBox {
            font-size: 15px;
            margin-top: 30px;
            color: var(--ink-1);
        }

        .err {
            color: var(--err);
        }
    </style>
</head>

<body>
    <h1>Analyzing your progress…</h1>
    <p class="muted">Please wait while we retrieve your adaptive learning status.</p>
    <p id="statusBox">Checking identity…</p>

    <script>
        /* ============================================================
           CONFIG
        ============================================================ */
        const PROXY_URL =
            "https://kh2do5aivc7hqegavqjeiwmd7q0smjqq.lambda-url.us-east-1.on.aws";

        const RULES_URL = "https://www.wirelearningsolutions.com/adaptive_rules.json";

        /* ============================================================
           1. GET QUERY PARAMETERS
        ============================================================ */
        const qs = new URLSearchParams(location.search);
        const learner = qs.get("learnerName") || "";
        const email = qs.get("email") || "";
        const sid = qs.get("sid") || "";

        /* Save identity for downstream pages */
        if (learner) localStorage.setItem("learnerName", learner);
        if (email) localStorage.setItem("learnerEmail", email);
        if (sid) localStorage.setItem("sessionId", sid);

        const statusBox = document.getElementById("statusBox");

        if (!learner && !email) {
            statusBox.innerHTML = `<span class="err">Missing learner identity.</span>`;
            throw new Error("Missing learner identity");
        }

        /* ============================================================
           2. FETCH ADAPTIVE RULES
        ============================================================ */
        async function loadRules() {
            statusBox.textContent = "Loading adaptive rules…";
            const res = await fetch(RULES_URL, { cache: "no-store" });
            if (!res.ok) throw new Error("Failed to load adaptive rules");
            return res.json();
        }

        /* ============================================================
           3. GET LRS SUMMARY FROM LAMBDA
        ============================================================ */
        async function loadSummary() {
            statusBox.textContent = "Reading your learning progress…";

            const url =
                PROXY_URL +
                "?mode=summary" +
                (learner ? "&learnerName=" + encodeURIComponent(learner) : "") +
                (email ? "&email=" + encodeURIComponent(email) : "");

            const res = await fetch(url);
            if (!res.ok) {
                statusBox.innerHTML = `<span class="err">Unable to read LRS summary.</span>`;
                throw new Error("LRS summary failed");
            }
            return res.json();
        }

        /* ============================================================
           4. BUILD ROUTE LIST BASED ON RULES
        ============================================================ */
        function buildRoutes(summary, rules) {
            statusBox.textContent = "Calculating the next step…";

            // Determine current competency
            const compOrder = ["C1", "C2", "C3"];
            let current = "C1";

            for (const c of compOrder) {
                if (!summary[c]) continue;
                const { mastery, finalized } = summary[c];
                if (!mastery && !finalized) {
                    current = c;
                    break;
                }
                // If finalized or mastered, move forward
                if (c === "C1" && (summary.C1.mastery || summary.C1.finalized)) current = "C2";
                if (c === "C2" && (summary.C2.mastery || summary.C2.finalized)) current = "C3";
            }

            const compRules = rules[current];
            if (!compRules) throw new Error("No rules for " + current);

            const mastery = summary[current]?.mastery || null;
            const finalized = summary[current]?.finalized || false;
            const missed = summary[current]?.missed || [];

            let pending = [];

            function applyRoute(r) {
                if (r.go) {
                    pending.push({ type: "go", target: r.go });
                }
                if (r.assessment) {
                    pending.push({ type: "assessment", target: r.assessment });
                }
                if (r.content) {
                    pending.push({ type: "content", target: r.content });
                }
                if (r.apply) {
                    pending.push({ type: "apply", target: r.apply });
                }
            }

            for (const rule of compRules) {
                const cond = rule.if;

                // finalized
                if (cond.finalized === true && finalized === true) {
                    rule.then.forEach(step => {
                        if (step.route) applyRoute(step.route);
                    });
                    return { current, pending };
                }

                // mastery exact
                if (cond.mastery && mastery === cond.mastery) {
                    rule.then.forEach(step => {
                        if (step.route) applyRoute(step.route);
                        if (step.forEach && Array.isArray(missed)) {
                            missed.forEach(item => {
                                step.do.forEach(d => {
                                    const routeCopy = JSON.parse(JSON.stringify(d.route));
                                    for (const k in routeCopy) {
                                        routeCopy[k] = routeCopy[k].replace("{item}", item);
                                    }
                                    applyRoute(routeCopy);
                                });
                            });
                        }
                    });
                    return { current, pending };
                }

                // masteryIn array
                if (cond.masteryIn && cond.masteryIn.includes(mastery)) {
                    rule.then.forEach(step => {
                        if (step.forEach && Array.isArray(step.forEach)) {
                            step.forEach.forEach(item => {
                                step.do.forEach(d => {
                                    const routeCopy = JSON.parse(JSON.stringify(d.route));
                                    for (const k in routeCopy) {
                                        routeCopy[k] = routeCopy[k].replace("{item}", item);
                                    }
                                    applyRoute(routeCopy);
                                });
                            });
                        }
                        if (step.route) applyRoute(step.route);
                    });
                    return { current, pending };
                }
            }

            return { current, pending };
        }

        /* ============================================================
           5. RESOLVE FIRST ROUTE TO A REAL URL
        ============================================================ */
        function resolveRoute(route) {
            const type = route.type;
            const target = route.target;

            if (type === "go") {
                return target + ".html";
            }

            if (type === "assessment") {
                return target + "/story.html";
            }

            if (type === "content") {
                return "content/" + target + ".html";
            }

            if (type === "apply") {
                const item = target.replace("-apply", "");
                return "apply/" + item + "/" + target + ".html";
            }

            throw new Error("Unknown route type: " + type);
        }

        /* ============================================================
           6. MAIN FLOW
        ============================================================ */
        (async () => {
            try {
                const rules = await loadRules();
                const summary = await loadSummary();

                const { pending } = buildRoutes(summary, rules);

                if (!pending.length) {
                    statusBox.innerHTML =
                        `<span class="err">No route generated.</span>`;
                    return;
                }

                const first = pending[0];
                const url = resolveRoute(first);

                statusBox.textContent = "Redirecting…";

                setTimeout(() => {
                    window.location.href = url +
                        "?learnerName=" + encodeURIComponent(learner) +
                        "&email=" + encodeURIComponent(email) +
                        "&sid=" + encodeURIComponent(sid);
                }, 600);

            } catch (err) {
                statusBox.innerHTML =
                    `<span class="err">Error: ${err.message}</span>`;
            }
        })();
    </script>

</body>
</html>
