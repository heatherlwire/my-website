<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Canonical redirect (top-level only) -->
    <script>
        if (window.top === window.self) {
            if (location.hostname === "wirelearningsolutions.com") {
                location.replace(
                    "https://www.wirelearningsolutions.com" +
                    location.pathname +
                    location.search
                );
            }
        }
    </script>

    <meta charset="UTF-8" />
    <title>Analyzing your progress…</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
        :root {
            --bg-0: #0a0f1a;
            --bg-1: #0e1526;
            --ink-0: #e8f1ff;
            --ink-1: #b9c8e8;
            --err: #ef4444;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
            color: var(--ink-0);
            background: linear-gradient(180deg,#07101e 0%,#0b1628 100%);
            min-height: 100vh;
            padding: 40px 18px;
            text-align: center;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 12px;
        }

        .muted {
            color: var(--ink-1);
        }

        #statusBox {
            margin-top: 24px;
            font-size: 15px;
            color: var(--ink-1);
        }

        .err {
            color: var(--err);
        }
    </style>
</head>

<body>
    <h1>Analyzing your progress…</h1>
    <p class="muted">Please wait while we retrieve your adaptive learning status.</p>
    <p id="statusBox">Checking identity…</p>

    <script>
        /* ============================================================
           CONFIG
        ============================================================ */
        const PROXY_URL =
            "https://kh2do5aivc7hqegavqjeiwmd7q0smjqq.lambda-url.us-east-1.on.aws";

        const RULES_URL =
            "https://www.wirelearningsolutions.com/adaptive_rules.json";

        const statusBox = document.getElementById("statusBox");

        /* ============================================================
           IDENTITY (QS + localStorage)
        ============================================================ */
        const qs = new URLSearchParams(location.search);

        let learnerName = qs.get("learnerName") || localStorage.getItem("learnerName") || "";
        let email = qs.get("email") || localStorage.getItem("learnerEmail") || "";
        let sid = qs.get("sid") || localStorage.getItem("sessionId") || "";

        if (learnerName) localStorage.setItem("learnerName", learnerName);
        if (email) localStorage.setItem("learnerEmail", email);
        if (sid) localStorage.setItem("sessionId", sid);

        /* If identity is totally missing, treat as fresh C1 pretest */
        if (!learnerName && !email) {
            statusBox.textContent = "Starting at C1 pretest…";
            setTimeout(() => {
                window.location.href =
                    "C1-test/story.html";
            }, 600);
            throw new Error("Missing identity");
        }

        /* Helper: append identity when redirecting */
        function withIdentity(url) {
            const sep = url.includes("?") ? "&" : "?";
            return (
                url +
                sep +
                "learnerName=" + encodeURIComponent(learnerName || "") +
                "&email=" + encodeURIComponent(email || "") +
                "&sid=" + encodeURIComponent(sid || "")
            );
        }

        /* ============================================================
           LOAD RULES
        ============================================================ */
        async function loadRules() {
            statusBox.textContent = "Loading adaptive rules…";
            const res = await fetch(RULES_URL, { cache: "no-store" });
            if (!res.ok) throw new Error("Failed to load adaptive rules");
            return res.json();
        }

        /* ============================================================
           LOAD SUMMARY (LRS → Lambda)
        ============================================================ */
        async function loadSummary() {
            statusBox.textContent = "Reading your progress from the LRS…";

            // If somehow identity is missing here, treat as no history
            if (!learnerName && !email) return {};

            const url =
                PROXY_URL +
                "?mode=summary" +
                (learnerName ? "&learnerName=" + encodeURIComponent(learnerName) : "") +
                (email ? "&email=" + encodeURIComponent(email) : "");

            const res = await fetch(url);
            if (!res.ok) {
                // On any error, just treat as no history (fresh learner)
                return {};
            }

            const data = await res.json();
            if (!data || typeof data !== "object") return {};

            // Always ensure keys exist
            return {
                C1: data.C1 || {},
                C2: data.C2 || {},
                C3: data.C3 || {}
            };
        }

        /* ============================================================
           DETECT CURRENT COMPETENCY
           (Based on JSON rules & summary)
        ============================================================ */
        function detectCurrent(summary) {
            const C1 = summary.C1 || {};
            const C2 = summary.C2 || {};
            const C3 = summary.C3 || {};

            const m1 = C1.mastery || null;
            const f1 = !!C1.finalized;
            const m2 = C2.mastery || null;
            const f2 = !!C2.finalized;
            const m3 = C3.mastery || null;
            const f3 = !!C3.finalized;

            // If C1 is not mastered or finalized yet → stay in C1
            if (!m1 && !f1) return "C1";
            if (m1 && m1 !== "Mastery" && !f1) return "C1";

            // C1 mastered/finalized → move to C2 unless C2 fully done
            if ((m1 === "Mastery" || f1) && (!m2 && !f2)) return "C2";
            if ((m1 === "Mastery" || f1) && (m2 && m2 !== "Mastery" && !f2)) return "C2";

            // C1 + C2 done (Mastery/finalized), but C3 not done → C3
            if ((m1 === "Mastery" || f1) &&
                (m2 === "Mastery" || f2) &&
                (!m3 && !f3)) return "C3";
            if ((m1 === "Mastery" || f1) &&
                (m2 === "Mastery" || f2) &&
                (m3 && m3 !== "Mastery" && !f3)) return "C3";

            // If everything has data, we still apply C3 rules (they route to program-complete)
            return "C3";
        }

        /* ============================================================
           APPLY RULES FOR ONE COMPETENCY
           (Exactly respects your JSON)
        ============================================================ */
        function buildRoutes(summary, rules) {
            const current = detectCurrent(summary);
            const compRules = rules[current];

            const result = { current, pending: [] };

            const state = summary[current] || {};
            const mastery = state.mastery || null;
            const finalized = !!state.finalized;
            const missed = Array.isArray(state.missed) ? state.missed : [];

            function pushRoute(routeObj) {
                const type = Object.keys(routeObj)[0];
                const target = routeObj[type];
                result.pending.push({ type, target });
            }

            if (!Array.isArray(compRules) || compRules.length === 0) {
                return result;
            }

            let matched = false;

            for (const rule of compRules) {
                const cond = rule.if || {};

                // 1) finalized
                if (cond.finalized === true && finalized === true) {
                    if (Array.isArray(rule.then)) {
                        for (const step of rule.then) {
                            if (step.route) pushRoute(step.route);
                        }
                    }
                    matched = true;
                    break;
                }

                // 2) mastery exact
                if (cond.mastery && mastery === cond.mastery) {
                    if (Array.isArray(rule.then)) {
                        for (const step of rule.then) {
                            // forEach = "missed" case (Proficient)
                            if (step.forEach === "missed" && Array.isArray(missed) && missed.length > 0) {
                                for (const item of missed) {
                                    for (const d of step.do || []) {
                                        const r = JSON.parse(JSON.stringify(d.route));
                                        for (const k in r) {
                                            r[k] = r[k].replace("{item}", item);
                                        }
                                        pushRoute(r);
                                    }
                                }
                            }
                            if (step.route) {
                                pushRoute(step.route);
                            }
                        }
                    }
                    matched = true;
                    break;
                }

                // 3) masteryIn array (Emerging / Failing)
                if (Array.isArray(cond.masteryIn) && cond.masteryIn.includes(mastery)) {
                    if (Array.isArray(rule.then)) {
                        for (const step of rule.then) {
                            // forEach = explicit array (e.g., ["C1a","C1b","C1c"])
                            if (Array.isArray(step.forEach)) {
                                for (const item of step.forEach) {
                                    for (const d of step.do || []) {
                                        const r = JSON.parse(JSON.stringify(d.route));
                                        for (const k in r) {
                                            r[k] = r[k].replace("{item}", item);
                                        }
                                        pushRoute(r);
                                    }
                                }
                            }
                            if (step.route) {
                                pushRoute(step.route);
                            }
                        }
                    }
                    matched = true;
                    break;
                }
            }

            // If NO rule matched (no mastery/finalized yet) → treat as fresh pretest for that competency
            if (!matched) {
                result.pending.push({
                    type: "assessment",
                    target: `${current}-test`
                });
            }

            return result;
        }

        /* ============================================================
           RESOLVE ROUTE → REAL URL
           (Follows your meta conventions)
        ============================================================ */
        function resolveRoute(route) {
            const { type, target } = route;

            // 1) go → can be "C2-test", "C3-test", or "program-complete"
            if (type === "go") {
                if (target === "program-complete") {
                    return "program-complete.html";
                }
                // e.g., "C2-test" → Storyline folder
                if (/-test$/.test(target)) {
                    return `${target}/story.html`;
                }
                return `${target}.html`;
            }

            // 2) assessment → "C1-test", "C2-test", "C3-test"
            if (type === "assessment") {
                return `${target}/story.html`;
            }

            // 3) content → "{item}-content"
            if (type === "content") {
                // target like "C1a-content" → content/C1a-content.html
                return `content/${target}.html`;
            }

            // 4) apply → "{item}-apply"
            if (type === "apply") {
                // target like "C1a-apply" → apply/C1a/C1a-apply.html
                const item = target.replace("-apply", "");
                return `apply/${item}/${target}.html`;
            }

            // Fallback: just return target.html to avoid hard breaks
            return `${target}.html`;
        }

        /* ============================================================
           MAIN FLOW
        ============================================================ */
        (async () => {
            try {
                const rules = await loadRules();
                const summary = await loadSummary();

                const { current, pending } = buildRoutes(summary, rules);

                if (!pending.length) {
                    // Should not happen, but just in case
                    statusBox.innerHTML =
                        "<span class='err'>No route found. Starting at C1 pretest…</span>";
                    setTimeout(() => {
                        window.location.href = withIdentity("C1-test/story.html");
                    }, 800);
                    return;
                }

                const first = pending[0];
                const url = resolveRoute(first);

                statusBox.textContent = "Redirecting to your next step…";

                setTimeout(() => {
                    window.location.href = withIdentity(url);
                }, 600);

            } catch (err) {
                console.error(err);
                statusBox.innerHTML =
                    "<span class='err'>We had trouble analyzing your progress. Starting at C1 pretest…</span>";
                setTimeout(() => {
                    window.location.href = withIdentity("C1-test/story.html");
                }, 900);
            }
        })();
    </script>

</body>
</html>
